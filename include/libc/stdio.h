/**
 * @file stdio.h
 * @defgroup libc_stdio <stdio.h>
 * @brief Input/output
 * @ingroup libc
 * 
 * @todo Detailed description
 * @todo See X documentation
 * 
 * @see [C documentation](https://en.cppreference.com/w/c/io)
 * for **File input/output**
 * 
 * @{
*/

#ifndef _LIBC_STDIO_H
#define _LIBC_STDIO_H 1

#include <stddef.h> // size_t
#include <stdarg.h> // va_list
#include <decl_FILE.h> // FILE

#ifdef __STDC_LIB_EXT1__ /* Bounds checking */
#include <errno.h> // errno_t
#endif


/*******************************************/
/* File Input/Output Functions             */
/* Ref: https://en.cppreference.com/w/c/io */
/*******************************************/

#define EOF (-1) ///< Integer constant expression of type `int` and negative value
#define FOPEN_MAX 16 ///< Maximum number of files that can be open simultaneously
#define FILENAME_MAX 4096 ///< Size needed for an array of `char` to hold the longest supported file name
#define BUFSIZ 8192 ///< Size of the buffer used by @ref setbuf
#define _IOFBF 0 ///< Argument to @ref setvbuf indicating fully buffered I/O
#define _IOLBF 1 ///< Argument to @ref setvbuf indicating line buffered I/O
#define _IONBF 2 ///< Argument to @ref setvbuf indicating unbuffered I/O
#define SEEK_SET 0 ///< Argument to @ref fseek indicating seeking from beginning of the file
#define SEEK_CUR 1 ///< Argument to @ref fseek indicating seeking from the current file position
#define SEEK_END 2 ///< Argument to @ref fseek indicating seeking from end of the file
#define TMP_MAX 238328 ///< Maximum number of unique filenames that can be generated by @ref tmpnam
#define L_tmpnam 20 ///< Size needed for an array of `char` to hold the result of @ref tmpnam

#ifdef __STDC_LIB_EXT1__ /* Bounds checking */
#define TMP_MAX_S 238328 /**< Maximum number of unique filenames that can be generated by @ref tmpnam_s */
#define L_tmpnam_s 20 /**< Size needed for an array of `char` to hold the result of @ref tmpnam_s */
#endif

/** @brief Non-array complete object type, capable of uniquely specifying a position and multibyte parser state in a file
 * 
 * `fpos_t` is a non-array complete object type, can be used to store (by
 * @ref fgetpos) and restore (by @ref fsetpos) the position and multibyte parser
 * state (if any) for a C stream.
 * 
 * The multibyte parser state of a wide-oriented C stream is represented by a
 * @ref mbstate_t object, whose value is stored as part of the value of a
 * `fpos_t` object by @ref fgetpos.
 * 
 * @see @ref fgetpos @copybrief fgetpos
 * @see @ref fsetpos @copybrief fsetpos
 * @see @ref mbstate_t @copybrief mbstate_t
*/
typedef struct {} fpos_t; // TODO: Implement

/** @brief Expression of type `FILE*` associated with the input stream
 * 
 * Associated with the *standard input stream*, used for reading conventional
 * input. At program startup, the stream is fully buffered if and only if the
 * stream can be determined to not refer to an interactive device.
 * 
 * What constitutes an interactive device is implementation-defined.
 * 
 * These macros are expanded to expressions of type `FILE*`.
 * 
 * @note Although not mandated by POSIX, the UNIX convention is that `stdin` and
 * @ref stdout are line-buffered if associated with a terminal and @ref stderr
 * is unbuffered.
 * @note These macros may be expanded to modifiable lvalues. If any of these
 * `FILE*` lvalue is modified, subsequent operations on the corresponding stream
 * result in unspecified or undefined behaviour.
 * 
 * @see @ref FILE @copybrief FILE
*/
#define stdin /* implementation defined */
// TODO: Implement

/** @brief Expression of type `FILE*` associated with the output stream
 * 
 * Associated with the *standard output stream*, used for writing conventional
 * output. At program startup, the stream is fully buffered if and only if the
 * stream can be determined to not refer to an interactive device.
 * 
 * What constitutes an interactive device is implementation-defined.
 * 
 * These macros are expanded to expressions of type `FILE*`.
 * 
 * @note Although not mandated by POSIX, the UNIX convention is that `stdin` and
 * @ref stdout are line-buffered if associated with a terminal and @ref stderr
 * is unbuffered.
 * @note These macros may be expanded to modifiable lvalues. If any of these
 * `FILE*` lvalue is modified, subsequent operations on the corresponding stream
 * result in unspecified or undefined behaviour.
 * 
 * @see @ref FILE @copybrief FILE
*/
#define stdout /* implementation defined */
// TODO: Implement

/** @brief Expression of type `FILE*` associated with the error output stream
 * 
 * Associated with the *standard error stream*, used for writing diagnostic
 * output. At program startup, the stream is not fully buffered.
 * 
 * What constitutes an interactive device is implementation-defined.
 * 
 * These macros are expanded to expressions of type `FILE*`.
 * 
 * @note Although not mandated by POSIX, the UNIX convention is that `stdin` and
 * @ref stdout are line-buffered if associated with a terminal and @ref stderr
 * is unbuffered.
 * @note These macros may be expanded to modifiable lvalues. If any of these
 * `FILE*` lvalue is modified, subsequent operations on the corresponding stream
 * result in unspecified or undefined behaviour.
 * 
 * @see @ref FILE @copybrief FILE
*/
#define stderr /* implementation defined */
// TODO: Implement

// TODO: Documentation, Opens a file
extern FILE* fopen(const char* restrict filename, const char* restrict mode);
#ifdef __STDC_LIB_EXT1__ /* Bounds checking */
// TODO: Documentation
extern errno_t fopen_s(FILE* restrict *restrict streamptr, const char* restrict filename, const char* restrict mode);
#endif

// TODO: Documentation, Opens an existing stream with a different name
extern FILE* freopen(const char* restrict filename, const char* restrict mode, FILE* restrict stream);
#ifdef __STDC_LIB_EXT1__ /* Bounds checking */
// TODO: Documentation
extern errno_t freopen_s(FILE* restrict *restrict newstreamptr, const char* restrict filename, const char* restrict mode, FILE* restrict stream);
#endif

// TODO: Documentation, Closes a file
extern int fclose(FILE* stream);

// TODO: Documentation, Synchronises an output stream with the actual file
extern int fflush(FILE* stream);

// TODO: Documentation, Sets the buffer for a file stream
extern void setbuf(FILE* restrict stream, char* restrict buffer);

// TODO: Documentation, Sets the buffer and its size for a file stream
extern int setvbuf(FILE* restrict stream, char* restrict buffer, int mode, size_t size);

// TODO: Documentation, Reads from a file
extern size_t fread(void* restrict buffer, size_t size, size_t count, FILE* restrict stream);

// TODO: Documentation, Writes to a file
extern size_t fwrite(const void* restrict buffer, size_t size, size_t count, FILE* restrict stream);

// TODO: Documentation, Gets a character from a file stream
extern int fgetc(FILE* stream);
extern int getc(FILE* stream);

// TODO: Documentation, Gets a character string from a file stream
extern char* fgets(char* restrict str, int count, FILE* restrict stream);

// TODO: Documentation, Writes a character to a file stream
extern int fputc(int ch, FILE* stream);
extern int putc(int ch, FILE* stream);

// TODO: Documentation, Writes a character string to a file stream
extern int fputs(const char* restrict str, FILE* restrict stream);

// TODO: Documentation, Reads a character from @ref stdin
extern int getchar(void);

// TODO: Documentation, Reads a character string from @ref stdin
#ifdef __STDC_LIB_EXT1__ /* Bounds checking */
char* gets_s(char* str, rsize_t n);
#endif
// NOTE: gets removed in C11

/** @brief Writes a character string from @ref stdin
 * 
 * Writes a character `ch` to @ref stdout. Internally, the character is
 * converted to `unsigned char` just before being written.
 * 
 * Equivalent to `putc(ch, stdout)`.
 * 
 * @param ch Character to be written
 * 
 * @returns On success, returns the written character.
 * @returns On failure, returns @ref EOF and sets the `error` indicator (see
 * @ref ferror) on @ref stdout.
 * 
 * @see @ref fputc and @ref putc, @copybrief putc
*/
extern int putchar(int ch);

/** @brief Writes a character string to @ref stdin
 * 
 * Writes every character from the null-terminated string `str` and one
 * additional newline character <tt>'\\n'</tt> to the output stream @ref stdout,
 * as if by repeatedly executing @ref fputc.
 * 
 * The terminating null character from `str` is not written.
 * 
 * @param str Character string to be written
 * 
 * @returns On success, returns a non-negative value.
 * @returns On failure, returns @ref EOF and sets the `error` indicator (see
 * @ref ferror) on `stream`.
 * 
 * @note The `puts` function appends the newline character to the output, while
 * @ref fputs function does not.
 * @note Different implementations return different non-negative numbers: some
 * return the last character written, some return the number of characters
 * written (or @ref INT_MAX if the string was longer than that), some simply
 * return a non-negative constant.
 * @note A typical cause of failure for `puts` is running out of space on the
 * file system, when @ref stdout is redirected to a file.
 * 
 * @see fputs @copybrief fputs
 * @see printf and it's variants, @copybrief printf
*/
extern int puts(const char* str);

// TODO: Documentation, Puts a character back into a file stream
extern int ungetc(int ch, FILE* stream);

// TODO: Documentation, Reads formatted inoput from @ref stdin, a file stream or a buffer
extern int scanf(const char* restrict format, ...);
extern int fscanf(FILE* restrict stream, const char* restrict format, ...);
extern int sscanf(const char* restrict buffer, const char* restrict format, ...);
#ifdef __STDC_LIB_EXT1__ /* Bounds checking */
extern int scanf_s(const char* restrict format, ...);
extern int fscanf_s(FILE* restrict stream, const char* restrict format, ...);
extern int sscanf_(const char* restrict buffer, const char* restrict format, ...);
#endif

// TODO: Documentation, Reads formatted input from @ref stdin, a file stream or a buffer using variable argument list
extern int vscanf(const char* restrict format, va_list vlist);
extern int vfscanf(FILE* restrict stream, const char* restrict format, va_list vlist);
extern int vsscanf(const char* restrict buffer, const char* restrict format, va_list vlist);
#ifdef __STDC_LIB_EXT1__ /* Bounds checking */
extern int vscanf_s(const char* restrict format, va_list vlist);
extern int vfscanf_s(FILE* restrict stream, const char* restrict format, va_list vlist);
extern int vsscanf_s(const char* restrict buffer, const char* restrict format, va_list vlist);
#endif

/** @brief Prints formatted output to @ref stdout, a file stream or a buffer
 * 
 * Loads the data from the given locations, converts them to character string
 * equivalents, and writes the results to the output stream @ref stdout.
 * 
 * @param format Pointer to a null-terminated byte string specifying how to
 * interpret the data
 * @param ... Arguments specifying data to print. If any argument after
 * [default argument promotions](https://en.cppreference.com/w/c/language/conversion#Default_argument_promotions)
 * is not the type expected by the corresponding conversion specifier, or if
 * there are fewer arguments than required by `format`, the behaviour is
 * undefined. If there are more arguments than required by `format`, the
 * extraneous arguments are evaluated and ignored.
 * 
 * @todo Docs for `format`?
 * 
 * @returns Number of characters transmitted to the output stream or negative
 * value if an output error or an encoding error (for string and character
 * conversion specifiers) occured.
 * 
 * @note [POSIX specifies](https://pubs.opengroup.org/onlinepubs/9699919799/functions/fprintf.html)
 * that @ref errno is set on error. It also specifies additional conversion
 * specifications, most notably support for argument reordering (`n$`
 * immediately after `%` indicates nth argument).
 * 
 * @see @ref wprintf and it's variants, @copybrief wprintf
 * @see @ref vprintf and it's variants, @copybrief vprintf
 * @see @ref fputs @copybrief fputs
 * @see @ref scanf and it's variants, @copybrief scanf
*/
extern int printf(const char* restrict format, ...);

// TODO: Docs for printf variants
extern int fprintf(FILE* restrict stream, const char* restrict format, ...);
extern int sprintf(char* restrict buffer, const char* restrict format, ...);
// extern int snprintf(char* restrict buffer, size_t bufsz, const char* restrict format, ...);
#ifdef __STDC_LIB_EXT1__ /* Bounds checking */
extern int printf_s(const char* restrict format, ...);
extern int fprintf_s(FILE* restrict stream, const char* restrict format, ...);
extern int sprintf_s(char* restrict buffer, rsize_t bufsz, const char* restrict format, ...);
extern int sprintf_s(char* restrict buffer, rsize_t bufsz, const char* restrict format, ...);
#endif

// TODO: Docs for vprintf variants
extern int vprintf(const char* restrict format, va_list vlist);
extern int vfprintf(FILE* restrict stream, const char* restrict format, va_list vlist);
extern int vsprintf(char* restrict buffer, const char* restrict format, va_list vlist);
extern int vsnprintf(char* restrict buffer, size_t bufsz, const char* restrict format, va_list vlist);
#ifdef __STDC_LIB_EXT1__ /* Bounds checking */
extern int vprintf_s(const char* restrict format, va_list vlist);
extern int vfprintf_s(FILE* restrict stream, const char* restrict format, va_list vlist);
extern int vsprintf_s(char* restrict buffer, rsize_t bufsz, const char* restrict format, va_list vlist);
extern int vsnprintf_s(char* restrict buffer, rsize_t bufsz, const char* restrict format, va_list vlist);
#endif

// TODO: Documentation, Returns the current file position indicator
extern long ftell(FILE* stream);

// TODO: Documentation, Gets the file position indicator
extern int fgetpos(FILE* restrict stream, fpos_t* restrict pos);

// TODO: Documentation, Moves the file position indicator to a specific location in a file
extern int fseek(FILE* stream, long offset, int origin);

// TODO: Documentation, Moves the file position indicator to a specific location in a file
extern int fsetpos(FILE* stream, const fpos_t* pos);

// TODO: Documentation, Moves the file position indicator to the beginning in a file
extern void rewind(FILE* stream);

// TODO: Documentation, Clears errors
extern void clearerr(FILE* stream);

// TODO: Documentation, Checks for the end-of-file
extern int feof(FILE* stream);

// TODO: Documentation, Checks for a file error
extern int ferror(FILE* stream);

// TODO: Documentation, Displays a character string corresponding of the current error to @ref stderr
extern void perror(const char* s);

// TODO: Documentation, Erases a file
extern int remove(const char* pathname);

// TODO: Documentation, Renames a file
extern int rename(const char* old_filename, const char* new_filename);

// TODO: Documentation, Returns a pointer to a temporary file
extern FILE* tmpfile(void);
#ifdef __STDC_LIB_EXT1__ /* Bounds checking */
extern errno_t tmpfile_s(FILE* restrict* restrict streamptr);
#endif

// TODO: Documentation, Returns a unique filename
extern char* tmpname(char* filename);
#ifdef __STDC_LIB_EXT1__ /* Bounds checking */
extern errno_t tmpnam_s(char* filename_s, rsize_t maxsize);
#endif

#endif

/** @} */
