/**
 * @file stdio.h
 * @defgroup libc_stdio <stdio.h>
 * @brief Input/output
 * @ingroup libc
 * 
 * @todo Detailed description
 * @todo See X documentation
 * 
 * @see [C documentation](https://en.cppreference.com/w/c/io)
 * for **File input/output**
 * 
 * @{
*/

#ifndef _LIBC_STDIO_H
#define _LIBC_STDIO_H 1

#include <stddef.h> // size_t
#include <stdarg.h> // va_list

#define EOF (-1) ///< Integer constant expression of type `int` and negative value
#define FOPEN_MAX 16 ///< Maximum number of files that can be open simultaneously
#define FILENAME_MAX 4096 ///< Size needed for an array of `char` to hold the longest supported file name
#define BUFSIZ 8192 ///< Size of the buffer used by @ref setbuf
#define _IOFBF 0 ///< Argument to @ref setvbuf indicating fully buffered I/O
#define _IOLBF 1 ///< Argument to @ref setvbuf indicating line buffered I/O
#define _IONBF 2 ///< Argument to @ref setvbuf indicating unbuffered I/O
#define SEEK_SET 0 ///< Argument to @ref fseek indicating seeking from beginning of the file
#define SEEK_CUR 1 ///< Argument to @ref fseek indicating seeking from the current file position
#define SEEK_END 2 ///< Argument to @ref fseek indicating seeking from end of the file
#define TMP_MAX 238328 ///< Maximum number of unique filenames that can be generated by @ref tmpnam
#define TMP_MAX_S 238328 ///< Maximum number of unique filenames that can be generated by @ref tmpnam_s
#define L_tmpnam 20 ///< Size needed for an array of `char` to hold the result of @ref tmpnam
#define L_tmpnam_s 20 ///< Size needed for an array of `char` to hold the result of @ref tmpnam_s

/** @brief Object type, capable of holding all information needed to control a C I/O stream
 * 
 * Each `FILE` object denotes a C stream.
 * 
 * C standard does not specify whether `FILE` is a complete object type. While
 * it may be possible to copy a valid `FILE`, using a pointer to such a copy as
 * an argument for an I/O function invokes unspecified behaviour. In other
 * words, `FILE` may be semantically non-copyable.
 * 
 * I/O streams can be used for both unformatted and formatted input and output.
 * Furthermore, the functions that handle input and output can also be
 * locale-sensitive, such that wide/multibyte conversions are performed as
 * necessary.
 * 
 * @todo Documentation for stream state
 * @todo Documentation for narrow and wide orientation
 * @todo Documentation for binary and text modes
 * @todo Documentation for notes
 * @todo FILE type implementation
 * 
 * @see @ref stdin @copybrief stdin
 * @see @ref stdout @copybrief stdout
 * @see @ref stderr @copybrief stderr
*/
typedef struct {} FILE; // TODO: Implement

// Ref: https://en.cppreference.com/w/c/io
// TODO: fpos_t
// TODO stdin, stdout, stderr
// TODO: fopen, fopen_s
// TODO: freopen, freopen_s
// TODO: fclose
// TODO: fflush
// TODO: setbuf
// TODO: setvbuf
// TODO: fread
// TODO: fwrite
// TODO: fgetc, getc
// TODO: fgets
// TODO: fputc, putc
// TODO: fputs
// TODO: getchar
// TODO: gets_s

/** @brief Writes a character string from @ref stdin
 * 
 * Writes a character `ch` to @ref stdout. Internally, the character is
 * converted to `unsigned char` just before being written.
 * 
 * Equivalent to `putc(ch, stdout)`.
 * 
 * @param ch Character to be written
 * 
 * @returns On success, returns the written character.
 * @returns On failure, returns @ref EOF and sets the `error` indicator (see
 * @ref ferror) on @ref stdout.
 * 
 * @see @ref fputc and @ref putc, @copybrief putc
*/
extern int putchar(int ch);

/** @brief Writes a character string to @ref stdin
 * 
 * Writes every character from the null-terminated string `str` and one
 * additional newline character <tt>'\\n'</tt> to the output stream @ref stdout,
 * as if by repeatedly executing @ref fputc.
 * 
 * The terminating null character from `str` is not written.
 * 
 * @param str Character string to be written
 * 
 * @returns On success, returns a non-negative value.
 * @returns On failure, returns @ref EOF and sets the `error` indicator (see
 * @ref ferror) on `stream`.
 * 
 * @note The `puts` function appends the newline character to the output, while
 * @ref fputs function does not.
 * @note Different implementations return different non-negative numbers: some
 * return the last character written, some return the number of characters
 * written (or @ref INT_MAX if the string was longer than that), some simply
 * return a non-negative constant.
 * @note A typical cause of failure for `puts` is running out of space on the
 * file system, when @ref stdout is redirected to a file.
 * 
 * @see fputs @copybrief fputs
 * @see printf and it's variants, @copybrief printf
*/
int puts(const char* str);

// Ref: https://en.cppreference.com/w/c/io
// TODO: ungetc
// TODO: scanf, fscanf, sscanf, scanf_s, fscanf_s, sscanf_s
// TODO: vscanf, vfscanf, vsscanf, vscanf_s, vfscanf_s, vsscanf_s

/** @brief Prints formatted output to @ref stdout, a file stream or a buffer
 * 
 * Loads the data from the given locations, converts them to character string
 * equivalents, and writes the results to the output stream @ref stdout.
 * 
 * @param format Pointer to a null-terminated byte string specifying how to
 * interpret the data
 * @param ... Arguments specifying data to print. If any argument after
 * [default argument promotions](https://en.cppreference.com/w/c/language/conversion#Default_argument_promotions)
 * is not the type expected by the corresponding conversion specifier, or if
 * there are fewer arguments than required by `format`, the behaviour is
 * undefined. If there are more arguments than required by `format`, the
 * extraneous arguments are evaluated and ignored.
 * 
 * @todo Docs for `format`?
 * 
 * @returns Number of characters transmitted to the output stream or negative
 * value if an output error or an encoding error (for string and character
 * conversion specifiers) occured.
 * 
 * @note [POSIX specifies](https://pubs.opengroup.org/onlinepubs/9699919799/functions/fprintf.html)
 * that @ref errno is set on error. It also specifies additional conversion
 * specifications, most notably support for argument reordering (`n$`
 * immediately after `%` indicates nth argument).
 * 
 * @see @ref wprintf and it's variants, @copybrief wprintf
 * @see @ref vprintf and it's variants, @copybrief vprintf
 * @see @ref fputs @copybrief fputs
 * @see @ref scanf and it's variants, @copybrief scanf
*/
extern int printf(const char* restrict format, ...);

// TODO: Docs for printf variants
extern int fprintf(FILE* restrict stream, const char* restrict format, ...);
extern int sprintf(char* restrict buffer, const char* restrict format, ...);
// extern int snprintf(char* restrict buffer, size_t bufsz, const char* restrict format, ...);
extern int printf_s(const char* restrict format, ...);
extern int fprintf_s(FILE* restrict stream, const char* restrict format, ...);
// extern int sprintf_s(char* restrict buffer, rsize_t bufsz, const char* restrict format, ...);
// extern int sprintf_s(char* restrict buffer, rsize_t bufsz, const char* restrict format, ...);

// TODO: Docs for vprintf variants
extern int vprintf(const char* restrict format, va_list vlist);
extern int vfprintf(FILE* restrict stream, const char* restrict format, va_list vlist);
extern int vsprintf(char* restrict buffer, const char* restrict format, va_list vlist);
extern int vsnprintf(char* restrict buffer, size_t bufsz, const char* restrict format, va_list vlist);
extern int vprintf_s(const char* restrict format, va_list vlist);
extern int vfprintf_s(FILE* restrict stream, const char* restrict format, va_list vlist);
// extern int vsprintf_s(char* restrict buffer, rsize_t bufsz, const char* restrict format, va_list vlist);
// extern int vsnprintf_s(char* restrict buffer, rsize_t bufsz, const char* restrict format, va_list vlist);

// Ref: https://en.cppreference.com/w/c/io
// TODO: ftell
// TODO: fgetpos
// TODO: fseek
// TODO: fsetpos
// TODO: rewind
// TODO: clearerr
// TODO: feof
// TODO: ferror
// TODO: perror
// TODO: remove
// TODO: rename
// TODO: tmpfile, tmpfile_s
// TODO: tmpnam, tmpnam_s

#endif

/** @} */


/************/
/* OLD CODE */
/************/

// // Needed for:
// // - L_tmpnam, minimum length for temporary file name
// // - TMP_MAX, number of temporary files
// // - FOPEN_MAX, potential limit of simultaneous open streams
// // - FILENAME_MAX, maximum length of file names
// #include <bits/stdio_lim.h>

// // Needed for:
// // - NULL, null pointer
// // - size_t, unsigned integral type
// #include <stddef.h>

// // Needed for:
// // - va_list
// #include <stdarg.h>


// /* Types */
// /// Object containing information to control a stream
// typedef struct _IO_FILE {} FILE; // TODO: Implement FILE type 

// /// Object containing information to specify a position within a file
// typedef struct __fpos_t {
// 	long __pos; ///< Type of file sizes and offsets
// 	struct {
// 		int __count;
// 		union {
// 			unsigned int __wch;
// 			char __wchb[4];
// 		} __value; ///< Value so far
// 	} __state; ///< Conversion state information
// } fpos_t;


// /* Standard streams */
// // TODO: Somehow define these. Has an issue with multiple definitions
// // FILE* stdin;  ///< Standard input stream
// // FILE* stdout; ///< Standard output stream
// // FILE* stderr; ///< Standard error output stream
// // // Quote: "C89/C99 say they're macros. Make them happy."
// // #define stdin stdin
// // #define stdout stdout
// // #define stderr stderr


// /** \addtogroup stdio_operations_on_files Operations on files
//  * @brief Remove/rename files, and temporary files
//  * @{
//  */
// int   remove(const char* filename); // Remove file
// int   rename(const char* oldname, const char* newname); // Rename file
// FILE* tmpfile(void); // Open a temporary file
// char* tmpnam(char* str); // Generate temporary filename // TODO: char[L_tmpnam] instead of char*
// /** @} */


// /** \addtogroup stdio_file_access File access
//  * @brief Open, flose, flush, and stream buffers
//  * @{
//  */
// int   fclose(FILE* stream); // Close file
// int   fflush(FILE* stream); // Flush stream
// FILE* fopen(const char* __restrict filename, const char* __restrict mode); // Open file
// FILE* freopen(const char* __restrict filename, const char* __restrict mode, FILE* __restrict stream); // Reopen stream with different file or mode
// void  setbuf(FILE* __restrict stream, char* __restrict buffer); // Set stream buffer
// int   setvbuf(FILE* __restrict stream, char* __restrict buffer, int mode, size_t size); // Change stream buffering
// /** @} */


// /** \addtogroup stdio_formatted_io Formatted input/output
//  * @brief Printing and scanning
//  * @{
//  */
// int fprintf(FILE* __restrict stream, const char* __restrict format, ...); // Write formatted data to stream
// int fscanf(FILE* __restrict stream, const char* __restrict format, ...); // Read formatted data from stream
// int printf(const char* __restrict format, ...); // Print formatted data to stdout
// int scanf(const char* __restrict format, ...); // Read formatted data from stdin
// int snprintf(char* __restrict s, size_t n, const char* __restrict format, ...); // Write formatted output to sized buffer
// int sprintf(char* __restrict str, const char* __restrict format, ...); // Write formatted data to string
// int sscanf(const char* __restrict s, const char* __restrict format, ...); // Read formatted data from string
// int vfprintf(FILE* __restrict stream, const char* __restrict format, va_list arg); // Write formatted data from variable argument list to stream
// int vfscanf(FILE* __restrict stream, const char* __restrict format, va_list arg); // Read formatted data from stream into variable argument list
// int vprintf(const char* __restrict format, va_list arg); // Print formatted data from variable argument list to stdout
// int vscanf(const char* __restrict format, va_list arg); // Read formatted data into variable argument list
// int vsnprintf(char* __restrict s, size_t n, const char* __restrict format, va_list arg); // Write formatted data from variable argument list to sized buffer
// int vsprintf(char* __restrict s, const char* __restrict format, va_list arg); // Write formatted data from variable argument list to string
// int vsscanf(const char* __restrict s, const char* __restrict format, va_list arg); // Read formatted data from string into variable argument list
// /** @} */


// /** \addtogroup stdio_character_io Character input/output
//  * @brief Get and put
//  * @{
//  */
// int   fgetc(FILE* stream); // Get character from stream
// char* fgets(char* __restrict str, int num, FILE* __restrict stream); // Get string from stream
// int   fputc(int character, FILE* stream); // Write character to stream
// int   fputs(const char* __restrict str, FILE* __restrict stream); // Write string to stream
// int   getc(FILE* stream); // Get character from stream
// int   getchar(void); // Get character from stdin
// // char* gets(char* str); // NOTE: Officially removed from ISO C11
// int   putc(int character, FILE* stream); // Write character to stream
// int   putchar(int character); // Write character to stdout
// int   puts(const char* str); // Write string to stdout
// int   ungetc(int character, FILE* stream); // Unget character from stream
// /** @} */


// /** \addtogroup stdio_direct_io Direct input/output
//  * @brief Read and write
//  * @{
//  */
// size_t fread(void* __restrict ptr, size_t size, size_t count, FILE* __restrict stream); // Read block of data from stream
// size_t fwrite(const void* __restrict ptr, size_t size, size_t count, FILE* __restrict stream); // Write block of data to stream
// /** @} */


// /** \addtogroup stdio_file_positioning File positioning
//  * @brief Seek and tell
//  * @{
//  */
// int      fgetpos(FILE* __restrict stream, fpos_t* __restrict pos); // Get current position in stream
// int      fseek(FILE* stream, long int offset, int origin); // Reposition stream position indicator
// int      fsetpos(FILE* stream, const fpos_t* pos); // Set position indicator of stream // TODO: restrict?
// long int ftell(FILE* stream); // Get current position in stream
// void     rewind(FILE* stream); // Set position of stream to the beginning
// /** @} */


// /** \addtogroup stdio_error_handling Error-handling
//  * @brief Print, check, and clear errors
//  * @{
//  */
// void clearerr(FILE* stream); // Clear error indicators
// int  feof(FILE* stream); // Check end-of-file indicator
// int  ferror(FILE* stream); // Check error indicator
// void perror(const char* str); // Print error message
// /** @} */
